classdef Robot_w_dist_JLATT < Robot_w_sens_and_comm
    %UNTITLED Summary of this class goes here
    %   Detailed explanation goes here

    properties
        Pose_est
        p_est
        process_cov
        R_mes
    end

    methods
        function obj = Robot_w_dist_JLATT(x0,name,sensor_data, connection_data, stat_data)
            obj@Robot_w_sens_and_comm(x0,name,sensor_data, connection_data)
            
            e_var0 = stat_data{1};
            w_var = stat_data{2};

            obj.Pose_est = x0;
            obj.Pose_est(3) = wrapTo2Pi(obj.Pose_est(3));

            obj.p_est = eye(3)*e_var0;

            obj.process_cov = eye(2)*w_var;
            obj.R_mes = eye(2)*obj.v_r;
            
        end

        function [x_ci, p_ci] = track_to_track_fusion(x_set, p_set)
            % let x be the estimate and p the estimated covariance set the
            % track to track algorithm combines different estimates of the
            % same variable toghether
            
            n = length(x_set);

            alpha_weights = zeros(1,n);
            for i = 1:n
                alpha_weights(i) = 1/trace(p_set{i});
            end
            alpha_weights = alpha_weights / sum(alpha_weights);

            p_ci_inv = zeros(size(p_set{1}));
            for i = 1:n
                p_ci_inv = p_ci_inv + alpha_weights(i)/p_set{i};
            end
            p_ci = inv(p_ci_inv);
            
            % Step 4: Calculate combined state estimate
            x_ci = zeros(size(x_set{1}));
            for i = 1:n
                x_ci = x_ci + alpha_weights(i) * (p_set{i} \ x_set{i});
            end
        end
        
        function x_next = dynamics_est(obj,pose_est,u,dt)
                w = [   randn*obj.process_cov(1,1);
                        randn*obj.process_cov(2,2)];

                x_next = pose_est + [   (u(1)-w(1))*cos(pose_est(3)); 
                                        (u(1)-w(1))*sin(pose_est(3)); 
                                            u(2)-w(2)]*dt;
        end

        function obj = propagate(obj)
            pose_est = obj.Pose_est;
            u = obj.u;
            dt = obj.dt;

            Phi = [ 1   0  -u(1)*dt*sin(pose_est(3));
                    0   1   u(1)*dt*cos(pose_est(3));
                    0   0   1];
            G = [   cos(pose_est(3))    0;
                    sin(pose_est(3))    0;
                    0                   1];

            Q = G*obj.process_cov*G';

            obj.p_est = Phi*obj.p_est*Phi' + Q;
            obj.Pose_est = obj.dynamics_est(pose_est,u,dt);
            obj.Pose_est(3) = wrapTo2Pi(obj.Pose_est(3));
        end
        
        function obj = update_rel_com(obj,robot_set, time_stamp)
            
            obj.data_rel = table('Size', [0 6], 'VariableTypes', {'double','double','double','double','double','double'}, 'VariableNames', {'Name', 'Distance','Direction','Pose_estimate', 'Error_covariance','Time'});
            
            for j=1:length(robot_set)
                robot = robot_set(j);
                hisRow = ismember(obj.z_r.Name, robot.name);
                
                if isempty(hisRow)
                    % don't add if he is so far I can't measure him
                else
                    distance = obj.z_r{hisRow, 'Distance'};

                    if distance < obj.link_max_dist
                    % if the robot is reachable then add the measurement 
                    % to be changed to follow the one hop rule
                        if rand < obj.rel_link_prob
            
                            myRow = ismember(robot.z_r.Name, obj.name);
                            my_distance = robot.z_r{myRow, 'Distance'};
                            my_direction = robot.z_r{myRow, 'Direction'};
            
                            rel_data = {robot.name, my_distance, my_direction, robot.Pose_est, robot.p_est, time_stamp };
                            
                            obj.data_rel = [obj.data_rel; rel_data];
            
                        end
                    end
                end
      
            end
        end
        
        function obj = update_com(obj,robot_set,time_stamp)

            obj = obj.update_rel_com(robot_set,time_stamp);
            
        end

        function obj = corrections_from_com(obj)
            n_corrections = height(obj.data_rel);
            s_set = {};
            y_set = {};

            %% Calculate corrections
            for l = 1:height(obj.data_rel)
                %% given robot_l's data
                data_row = obj.data_rel(l,:);
                sender_name = data_row.Name;
                sender_zr_row = ismember(obj.z_r.Name, sender_name);
                zr_row = obj.z_r(sender_zr_row,:);
                
                z_il = [data_row.Distance;  data_row.Direction]; % data received from l
                z_li = [zr_row.Distance;    zr_row.Direction];  % measurement I have of l

                Pose_l = data_row.Pose_estimate{1};
                p_l = data_row.Error_covariance{1};
                Pose_i = obj.Pose_est;
                p_i = obj.p_est;
                

                %% measurement error 
                % distance correction
                distance_diff = z_il(1) - z_li(1);
                % angle corrections
                
                phi_il = wrapTo2Pi(z_il(2)) + wrapTo2Pi(Pose_l(3));
                phi_li = wrapTo2Pi(z_li(2)) + wrapTo2Pi(Pose_i(3));
                
                dphi_il = phi_il- phi_li + pi;
                dphi_il = wrapTo2Pi(dphi_il);
                if dphi_il > 2*pi-0.001
                    dphi_il = 0;
                end

                dz_il = [distance_diff; dphi_il]; 
                dz_il(dz_il<0.001) = 0;
                
                %% H matrices
                dx = Pose_l(1) - Pose_i(1);
                dy = Pose_l(2) - Pose_i(2);

                H_i = [ -dx/sqrt(dx^2 + dy^2)   -dy/sqrt(dx^2 + dy^2)   0;
                        -dy/(dx^2 + dy^2)       dx/(dx^2+dy^2)          -1];
                H_i(H_i < 1e-5) = 0;
                H_i = H_i + 1e-5 * eye(size(H_i));

                H_l = [ dx/sqrt(dx^2 + dy^2)    dy/sqrt(dx^2 + dy^2)    0;
                        dy/(dx^2 + dy^2)        -dx/(dx^2+dy^2)         0];
                H_l(H_l < 1e-5) = 0;
                H_l = H_l + 1e-5 * eye(size(H_l));

                R_hat = obj.R_mes + H_l*p_l*H_l';
                R_hat(R_hat < 0.1) = 0;
                R_hat = R_hat + 1e-3 * eye(size(R_hat));

                %% corrections
                s_l = H_i'*inv(R_hat)*H_i;
                y_l = H_i'*inv(R_hat)*(dz_il + H_i*Pose_i);

                s_l(s_l < 0.001) = 0;
                y_l(y_l < 0.001) = 0;

                %% save
                s_set(end+1,:) = {s_l};
                y_set(end+1,:) = {y_l};

            end
            
            if isempty(s_set)
                % dont update if I dont have data
            else
                %% Compute update terms
                nu = 1/n_corrections; % I am only updating from relative measurements
                
                inv_p_hat = 0;
                for i=1:height(s_set)
                    inv_p_hat = inv_p_hat + nu*s_set{i};
                end
                inv_p_hat(inv_p_hat < 0.1) = 0;
                inv_p_hat = inv_p_hat + 1e-5 * eye(size(inv_p_hat));

                p_hat = inv(inv_p_hat);
                
                

                x_hat = 0;
                for i=1:height(y_set)
                    x_hat = x_hat + nu*inv_p_hat*y_set{i};
                end
                
                p_est = obj.p_est;
                p_est(p_est < 0.1) = 0;
                p_est = p_est + 1e-3 * eye(size(p_est));
    
                Omega = inv(p_est);
                q = inv(p_est)*obj.Pose_est;
                
                % update coeff
                hat_contr = trace(p_hat)^-1;
                est_contr = trace(p_est)^-1;
                alpha = hat_contr/(hat_contr + est_contr+1e-5); % value from (0,1) to minimize the resulting Trace(p_est) 
                
                temp = alpha*inv_p_hat + (1-alpha)*Omega;
                p_est(p_est < 0.1) = 0;
                p_est = p_est + 1e-3 * eye(size(p_est));

                Gamma = inv_p_hat*inv(temp)*Omega;
                K = Omega - alpha*Gamma;
                L = inv_p_hat - (1-alpha)*Gamma;
                
                %% Update
                obj.p_est = inv(Omega + inv_p_hat - Gamma);          
                obj.Pose_est = obj.p_est*(K*inv(Omega)*q + L*x_hat);   
                obj.Pose_est(3) = mod(obj.Pose_est(3), 2*pi);
            end
            

        end

        function draw_estimate(obj)
            % Given pose and covariance matrix
            pose = obj.Pose_est; % Replace with your actual pose
            P = obj.p_est; % Your 2x2 covariance matrix for x and y
            
            % Plot the position
            plot(pose(1), pose(2), 'bo'); % 'bo' plots a blue circle at the position
            
            % Plot the uncertainty ellipse for x and y
            % Extract the 2x2 covariance matrix for x and y
            P_position = P(1:2, 1:2);
            % Calculate the eigenvalues and eigenvectors of the covariance matrix
            [eigvec, eigval] = eig(P_position);
            
            % Get the largest eigenvalue and its corresponding eigenvector
            [largest_eigenval, largest_eigenvec_ind_c] = max(diag(eigval));
            largest_eigenvec = eigvec(:, largest_eigenvec_ind_c);
            
            % Get the smallest eigenvalue
            if largest_eigenvec_ind_c == 1
                smallest_eigenval = eigval(2,2);
            else
                smallest_eigenval = eigval(1,1);
            end
            
            % Calculate the angle between the x-axis and the largest eigenvector
            angle = atan2(largest_eigenvec(2), largest_eigenvec(1));
            
            % Get the 95% confidence interval error ellipse
            chisquare_val = 5.991; % 95% confidence interval for 2 degrees of freedom
            theta_grid = linspace(0, 2*pi, 100);
            phi = angle;
            X0 = pose(1);
            Y0 = pose(2);
            a = sqrt(chisquare_val*largest_eigenval);
            b = sqrt(chisquare_val*smallest_eigenval);
            
            % the ellipse in x and y coordinates
            ellipse_x_r = a*cos(theta_grid);
            ellipse_y_r = b*sin(theta_grid);
            
            % Define a rotation matrix
            R = [cos(phi) sin(phi); -sin(phi) cos(phi)];
            
            % Rotate the ellipse
            r_ellipse = [ellipse_x_r; ellipse_y_r]' * R;
            
            % Draw the error ellipse
            plot(r_ellipse(:,1) + X0, r_ellipse(:,2) + Y0, 'r');
            
            % Plot the heading
            head_length = 0.5; % Length of the heading line, adjust as needed
            heading_vector = [cos(pose(3)), sin(pose(3))] * head_length;
            quiver(pose(1), pose(2), heading_vector(1), heading_vector(2), 0, 'k', 'LineWidth', 2);
            
            
        end
    
    end
end